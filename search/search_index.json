{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LoRa Paw","text":"<p>NOTICE</p> <p>The LoRa paw documentation is still under construction and is not fully complete.</p>"},{"location":"projects/rickroll/","title":"LoRa Rickroll","text":"<p>Ever wanted to rickroll your friends from a long distance? </p> <p>Here's Kody doing it, after that, you give it a try!</p>"},{"location":"projects/rickroll/#setting-up-the-environment","title":"Setting up the environment","text":"<p>The LoRa Paw can easily be interfaced using CircuitPython. To flash it to your nugget, simply head over to our flashing site.</p> <p>From there, our next step is to install the dependencies.</p>"},{"location":"projects/rickroll/#satisfying-dependency-requirements","title":"Satisfying dependency requirements","text":"<p>This project requires the following libraries: <code>adafruit_rfm9x</code>, <code>adafruit_displayio_sh1106</code>, <code>adafruit_hid</code>, and <code>adafruit_ducky</code>.</p> <p>You can download these from CircuitPython's website. Note you will need Bundle version <code>9.x</code>.</p>"},{"location":"projects/rickroll/#coding-the-rickroll","title":"Coding the Rickroll","text":"<p>In order to perform a rickroll over Lora, several things must happen: - Broadcasting device sends trigger code - Receiving device picks up trigger code - Receiving device executes Catscratch payload</p> <p>Luckily for us, this is a fairly simple task that involves modifying <code>code.py</code>, and creating a duckyscript payload (<code>payload.txt</code>).</p> <p>Warning</p> <p>Pinouts vary between USB and Bluetooth Nuggets. Be sure it matches the pinouts</p> code.py<pre><code># SPDX-FileCopyrightText: 2024 ladyada for Adafruit Industries &amp; Skicka\n# SPDX-License-Identifier: MITs\n\n# Simple demo of sending and recieving data with the RFM95 LoRa radio.\n# Author: Tony DiCola / Kody Kinzie\nimport board\nimport busio\nimport digitalio\nimport neopixel\nimport adafruit_rfm9x\nimport displayio\nimport terminalio\nfrom adafruit_display_text import label\nimport busio\nfrom adafruit_displayio_sh1106 import SH1106\nimport neopixel\nimport time\nimport usb_hid\nfrom adafruit_hid.keyboard import Keyboard\nfrom adafruit_hid.keyboard_layout_us import KeyboardLayoutUS\nimport usb_hid\nfrom adafruit_hid.keyboard import Keyboard\nfrom adafruit_hid.keyboard_layout_us import KeyboardLayoutUS\nimport adafruit_ducky\n\ntime.sleep(1)  # Sleep for a bit to avoid a race condition on some systems\nkeyboard = Keyboard(usb_hid.devices)\nkeyboard_layout = KeyboardLayoutUS(keyboard)  # We're in the US :)\nduck = adafruit_ducky.Ducky(\"payload.txt\", keyboard, keyboard_layout)\n\ndef RickMe():\n    result = True\n    while result is not False:\n        result = duck.loop()\n\n# Release any resources currently in use for the displays\ndisplayio.release_displays()\n\ni2c = busio.I2C(scl=board.SCL, sda=board.SDA)\ndisplay_bus = displayio.I2CDisplay(i2c, device_address=0x3C)\n\n# Define the width and height of the display\nWIDTH = 130\nHEIGHT = 64\ndisplay = SH1106(display_bus, width=WIDTH, height=HEIGHT)\n\n\n\npixel = neopixel.NeoPixel(board.IO12, 4, brightness=0.2)\npixel[0] = (0,0,255)  # equivalent\n\n\n# Define radio parameters.\nRADIO_FREQ_MHZ = 915.0  # Frequency of the radio in Mhz. Must match your\n# module! Can be a value like 915.0, 433.0, etc.\n\n# Define pins connected to the chip, use these if wiring up the breakout according to the guide:\nCS = digitalio.DigitalInOut(board.IO13)\nRESET = digitalio.DigitalInOut(board.IO5)\n# Or uncomment and instead use these if using a Feather M0 RFM9x board and the appropriate\n# CircuitPython build:\n# CS = digitalio.DigitalInOut(board.RFM9X_CS)\n# RESET = digitalio.DigitalInOut(board.RFM9X_RST)\n\n\n# Initialize SPI bus.\nspi = busio.SPI(board.IO6, MOSI=board.IO10, MISO=board.IO8)\n\n# Initialze RFM radio\nrfm9x = adafruit_rfm9x.RFM9x(spi, CS, RESET, RADIO_FREQ_MHZ)\n\n# Note that the radio is configured in LoRa mode so you can't control sync\n# word, encryption, frequency deviation, or other settings!\n\n# You can however adjust the transmit power (in dB).  The default is 13 dB but\n# high power radios like the RFM95 can go up to 23 dB:\nrfm9x.tx_power = 23\n\n# Send a packet.  Note you can only send a packet up to 252 bytes in length.\n# This is a limitation of the radio packet size, so if you need to send larger\n# amounts of data you will need to break it into smaller send calls.  Each send\n# call will wait for the previous one to finish before continuing.\npixel[0] = (255,0,0)  # equivalent\nrfm9x.send(bytes(\"Ping\", \"utf-8\"))\nprint(\"Sent Ping message!\")\npixel[0] = (0,0,255)  # equivalent\n# Wait to receive packets.  Note that this library can't receive data at a fast\n# rate, in fact it can only receive and process one 252 byte packet at a time.\n# This means you should only use this for low bandwidth scenarios, like sending\n# and receiving a single message at a time.\n#print(\"Waiting for packets...\")\n\nrxCounter = 0\n\nwhile True:\n    packet = rfm9x.receive()\n    # Optionally change the receive timeout from its default of 0.5 seconds:\n    # packet = rfm9x.receive(timeout=5.0)\n    # If no packet was received during the timeout then None is returned.\n    if packet is None:\n        # Packet has not been received\n        pixel[0] = (0,0,255)  # equivalent\n        #print(\"Received nothing! Listening again...\")\n    else:\n        # Received a packet!\n        rxCounter = rxCounter + 1\n        pixel[0] = (0,255,0)  # equivalent\n        # Print out the raw bytes of the packet:\n        print(\"Packet Count: {}\".format(rxCounter))\n        # And decode to ASCII text and print it too.  Note that you always\n        # receive raw bytes and need to convert to a text format like ASCII\n        # if you intend to do string processing on your data.  Make sure the\n        # sending side is sending ASCII data before you try to decode!\n        packet_text = str(packet, \"ascii\")\n        print(\"Msg: {0}\".format(packet_text))\n        # Also read the RSSI (signal strength) of the last received message and\n        # print it.\n        rssi = rfm9x.last_rssi\n        print(\"RSSI: {0} dB\".format(rssi))\n        if \"rickme\" in packet_text:\n            RickMe()\n        #time.sleep(3)\n</code></pre> <p>And finally, our payload:</p> payload.txt<pre><code>DELAY 1000\nGUI SPACE\nDELAY 1000\nSTRING terminal.app\nENTER\nDELAY 1000\nSTRING open \"https://youtu.be/dQw4w9WgXcQ\"\nENTER\nDELAY 5000\nSPACE\n</code></pre>"},{"location":"technical/binaries/","title":"LoRa Paw Binaries","text":"<p>NOTICE</p> <p>Software for the LoRa Paw is still under development. However, you can download the latest beta binaries here.</p> USB NuggetBluetooth Nugget <p>Download USB Nugget Binary</p> <p>Download Bluetooth Nugget Binary</p>"},{"location":"technical/pinouts/","title":"Pinout","text":"TopBottom <p> Top Pinout of the LoRa Paw</p> <p> Bottom Pinout of the LoRa Paw</p>"},{"location":"technical/schematics/","title":"Schematics","text":"DefinitionsSchematic <p> Component Definitions for the LoRa Paw</p> <p> Schematic for the LoRa Paw</p> <p>Download</p>"}]}