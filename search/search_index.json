{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LoRa Paw","text":"<p>The LoRa paw is an addon for the USB Nugget, giving it LoRa capabilities. It's based on the RFM95W module from HopeRF.</p> <p>Interfacing with the LoRa paw is extremely easy, as libraries are available both in CircuitPython and Arduino.</p> <p>You can order one today from our store.</p> <p>Note</p> <p>If you have one of our V1 Prototypes that look like the picture below, please refer to this GitHub link for pinouts and example code. The design has been updated, and they are not supported in this guide. </p>"},{"location":"guides/examples/","title":"Code Examples","text":""},{"location":"guides/examples/#sending-a-hello-world","title":"Sending a Hello World","text":""},{"location":"guides/examples/#transmitter","title":"Transmitter","text":"USB NuggetBluetooth Nugget <pre><code>  # Send Hello World on the USB Nugget (ESP32s2)\n  import board\n  import busio\n  import digitalio\n  import adafruit_rfm9x\n\n  # Initialize SPI interface.\n  spi = busio.SPI(board.IO6, MOSI=board.IO10, MISO=board.IO8)\n\n  # Initialize RFM9x LoRa radio\n  CS = digitalio.DigitalInOut(board.IO13)\n  RESET = digitalio.DigitalInOut(board.IO5)\n  rfm9x = adafruit_rfm9x.RFM9x(spi, CS, RESET, 915.0)\n  rfm9x.tx_power = 23\n\n  # Send text without specifiyng encoding\n  message = \"Hello World!\"\n  rfm9x.send(message)\n  print(\"Sent Hello World string!\")\n\n\n  #Send the same text, specify utf-8 bytes\n  rfm9x.send(bytes(\"Hello world!\\r\\n\", \"utf-8\"))\n  print(\"Sent Hello World bytes!\")\n</code></pre> <pre><code># Send Hello World on the Bluetooth Nugget (ESP32s3)\nimport board\nimport busio\nimport digitalio\nimport adafruit_rfm9x\n\n# Initialize SPI interface\nspi = busio.SPI(board.IO6, MOSI=board.IO8, MISO=board.IO7)\n\n# Initialize RFM9x LoRa radio\nCS = digitalio.DigitalInOut(board.IO9)\nRESET = digitalio.DigitalInOut(board.IO4)\nrfm9x = adafruit_rfm9x.RFM9x(spi, CS, RESET, 915.0)\nrfm9x.tx_power = 23\n\n# Send text without specifiyng encoding\nmessage = \"Hello World!\"\nrfm9x.send(message)\nprint(\"Sent Hello World string!\")\n\n\n#Send the same text, specify utf-8 bytes\nrfm9x.send(bytes(\"Hello world!\\r\\n\", \"utf-8\"))\nprint(\"Sent Hello World bytes!\")\n</code></pre>"},{"location":"guides/examples/#receiver","title":"Receiver","text":"USB NuggetBluetooth Nugget <pre><code># Recieve Hello World on the USB Nugget (ESP32s2)\nimport board\nimport busio\nimport digitalio\nimport adafruit_rfm9x\n\n# Initialize SPI interface.\nspi = busio.SPI(board.IO6, MOSI=board.IO10, MISO=board.IO8)\n\n# Initialize RFM9x LoRa radio\nCS = digitalio.DigitalInOut(board.IO13)\nRESET = digitalio.DigitalInOut(board.IO5)\nrfm9x = adafruit_rfm9x.RFM9x(spi, CS, RESET, 915.0)\nrfm9x.tx_power = 23\n\nwhile True:\n    packet = rfm9x.receive()\n    if packet is None:\n        print(\"Received nothing! Listening again...\")\n    else:\n        print(\"Received (raw bytes):\", packet)\n        # you always receive raw bytes and need to convert to a text\n        # format like ASCII if you intend to do string processing.\n        packet_text = str(packet, \"ascii\")\n        print(\"Received (ASCII):\", packet_text)\n        # Also read the signal strength of the received message and print it.\n        signal = rfm9x.last_rssi\n        print(\"Received signal strength:\", signal)\n</code></pre> <pre><code>  # Recieve Hello World on the Bluetooth Nugget (ESP32s3)\n  import board\n  import busio\n  import digitalio\n  import adafruit_rfm9x\n\n  # Initialize SPI interface\n  spi = busio.SPI(board.IO6, MOSI=board.IO8, MISO=board.IO7)\n\n  # Initialize RFM9x LoRa radio\n  CS = digitalio.DigitalInOut(board.IO9)\n  RESET = digitalio.DigitalInOut(board.IO4)\n  rfm9x = adafruit_rfm9x.RFM9x(spi, CS, RESET, 915.0)\n  rfm9x.tx_power = 23\n\n  while True:\n      packet = rfm9x.receive()\n      if packet is None:\n          print(\"Received nothing! Listening again...\")\n      else:\n          print(\"Received (raw bytes):\", packet)\n          # you always receive raw bytes and need to convert to a text\n          # format like ASCII if you intend to do string processing.\n          packet_text = str(packet, \"ascii\")\n          print(\"Received (ASCII):\", packet_text)\n          # Also read the signal strength of the received message and print it.\n          signal = rfm9x.last_rssi\n          print(\"Received signal strength:\", signal)\n</code></pre>"},{"location":"guides/examples/#packet-repeater","title":"Packet Repeater","text":"USB NuggetBluetooth Nugget <pre><code>  # Repeat a received packet on the USB Nugget (ESP32s2)\n\n  import board\n  import busio\n  import digitalio\n  import adafruit_rfm9x\n  import time\n\n  # Initialize SPI interface.\n  spi = busio.SPI(board.IO6, MOSI=board.IO10, MISO=board.IO8)\n\n  # Initialize RFM9x LoRa radio\n  CS = digitalio.DigitalInOut(board.IO13)\n  RESET = digitalio.DigitalInOut(board.IO5)\n  rfm9x = adafruit_rfm9x.RFM9x(spi, CS, RESET, 915.0)\n  rfm9x.tx_power = 23\n\n  # Send text without specifiyng encoding\n  message = \"Ping!\"\n  rfm9x.send(message)\n  print(\"Sent Ping!\")\n\n  while True:\n      packet = rfm9x.receive()\n      # If no packet was received during the timeout then None is returned.\n      if packet is None:\n          print(\"Received nothing! Listening again...\")\n      else:\n          print(\"Received (raw bytes):\", packet)\n          # you always receive raw bytes and need to convert to a text\n          # format like ASCII if you intend to do string processing.\n          packet_text = str(packet, \"ascii\")\n          print(\"Received (ASCII):\", packet_text)\n          # Also read the signal strength of the received message and print it.\n          signal = rfm9x.last_rssi\n          print(\"Received signal strength:\", signal)\n          # Rebroadcast the packet\n          time.sleep(1)\n          print(\"Rebroadcasting packet...\")\n          rfm9x.send(packet_text)\n          print(\"Sent!\")\n</code></pre> <pre><code>  # Repeat a received packet on the Bluetooth Nugget (ESP32s3)\n\n  import board\n  import busio\n  import digitalio\n  import adafruit_rfm9x\n  import time\n\n  # Initialize SPI interface\n  spi = busio.SPI(board.IO6, MOSI=board.IO8, MISO=board.IO7)\n\n  # Initialize RFM9x LoRa radio\n  CS = digitalio.DigitalInOut(board.IO9)\n  RESET = digitalio.DigitalInOut(board.IO4)\n  rfm9x = adafruit_rfm9x.RFM9x(spi, CS, RESET, 915.0)\n  rfm9x.tx_power = 23\n\n  # Send text without specifiyng encoding\n  message = \"Ping!\"\n  rfm9x.send(message)\n  print(\"Sent Ping!\")\n\n  while True:\n      packet = rfm9x.receive()\n      # If no packet was received during the timeout then None is returned.\n      if packet is None:\n          print(\"Received nothing! Listening again...\")\n      else:\n          print(\"Received (raw bytes):\", packet)\n          # you always receive raw bytes and need to convert to a text\n          # format like ASCII if you intend to do string processing.\n          packet_text = str(packet, \"ascii\")\n          print(\"Received (ASCII):\", packet_text)\n          # Also read the signal strength of the received message and print it.\n          signal = rfm9x.last_rssi\n          print(\"Received signal strength:\", signal)\n          # Rebroadcast the packet\n          time.sleep(1)\n          print(\"Rebroadcasting packet...\")\n          rfm9x.send(packet_text)\n          print(\"Sent!\")\n</code></pre>"},{"location":"guides/rickroll/","title":"LoRa Rickroll","text":"<p>Ever wanted to rickroll your friends from a long distance? </p> <p>Here's Kody doing it, after that, you give it a try!</p>"},{"location":"guides/rickroll/#setting-up-the-environment","title":"Setting up the environment","text":"<p>The LoRa Paw can easily be interfaced using CircuitPython. To flash it to your nugget, simply head over to our flashing site.</p> <p>From there, our next step is to install the dependencies.</p>"},{"location":"guides/rickroll/#satisfying-dependency-requirements","title":"Satisfying dependency requirements","text":"<p>This project requires the following libraries: <code>adafruit_rfm9x</code>, <code>adafruit_displayio_sh1106</code>, <code>adafruit_hid</code>, and <code>adafruit_ducky</code>.</p> <p>You can download these from CircuitPython's website. Note you will need Bundle version <code>9.x</code>.</p>"},{"location":"guides/rickroll/#coding-the-rickroll","title":"Coding the Rickroll","text":"<p>In order to perform a rickroll over Lora, several things must happen: - Broadcasting device sends trigger code - Receiving device picks up trigger code - Receiving device executes Catscratch payload</p> <p>Luckily for us, this is a fairly simple task that involves modifying <code>code.py</code>, and creating a duckyscript payload (<code>payload.txt</code>).</p> <p>Warning</p> <p>Pinouts vary between USB and Bluetooth Nuggets. Be sure it matches the pinouts</p> code.py<pre><code># SPDX-FileCopyrightText: 2024 ladyada for Adafruit Industries &amp; Skicka\n# SPDX-License-Identifier: MITs\n\n# Simple demo of sending and recieving data with the RFM95 LoRa radio.\n# Author: Tony DiCola / Kody Kinzie\nimport board\nimport busio\nimport digitalio\nimport neopixel\nimport adafruit_rfm9x\nimport displayio\nimport terminalio\nfrom adafruit_display_text import label\nimport busio\nfrom adafruit_displayio_sh1106 import SH1106\nimport neopixel\nimport time\nimport usb_hid\nfrom adafruit_hid.keyboard import Keyboard\nfrom adafruit_hid.keyboard_layout_us import KeyboardLayoutUS\nimport usb_hid\nfrom adafruit_hid.keyboard import Keyboard\nfrom adafruit_hid.keyboard_layout_us import KeyboardLayoutUS\nimport adafruit_ducky\n\ntime.sleep(1)  # Sleep for a bit to avoid a race condition on some systems\nkeyboard = Keyboard(usb_hid.devices)\nkeyboard_layout = KeyboardLayoutUS(keyboard)  # We're in the US :)\nduck = adafruit_ducky.Ducky(\"payload.txt\", keyboard, keyboard_layout)\n\ndef RickMe():\n    result = True\n    while result is not False:\n        result = duck.loop()\n\n# Release any resources currently in use for the displays\ndisplayio.release_displays()\n\ni2c = busio.I2C(scl=board.SCL, sda=board.SDA)\ndisplay_bus = displayio.I2CDisplay(i2c, device_address=0x3C)\n\n# Define the width and height of the display\nWIDTH = 130\nHEIGHT = 64\ndisplay = SH1106(display_bus, width=WIDTH, height=HEIGHT)\n\n\n\npixel = neopixel.NeoPixel(board.IO12, 4, brightness=0.2)\npixel[0] = (0,0,255)  # equivalent\n\n\n# Define radio parameters.\nRADIO_FREQ_MHZ = 915.0  # Frequency of the radio in Mhz. Must match your\n# module! Can be a value like 915.0, 433.0, etc.\n\n# Define pins connected to the chip, use these if wiring up the breakout according to the guide:\nCS = digitalio.DigitalInOut(board.IO13)\nRESET = digitalio.DigitalInOut(board.IO5)\n# Or uncomment and instead use these if using a Feather M0 RFM9x board and the appropriate\n# CircuitPython build:\n# CS = digitalio.DigitalInOut(board.RFM9X_CS)\n# RESET = digitalio.DigitalInOut(board.RFM9X_RST)\n\n\n# Initialize SPI bus.\nspi = busio.SPI(board.IO6, MOSI=board.IO10, MISO=board.IO8)\n\n# Initialze RFM radio\nrfm9x = adafruit_rfm9x.RFM9x(spi, CS, RESET, RADIO_FREQ_MHZ)\n\n# Note that the radio is configured in LoRa mode so you can't control sync\n# word, encryption, frequency deviation, or other settings!\n\n# You can however adjust the transmit power (in dB).  The default is 13 dB but\n# high power radios like the RFM95 can go up to 23 dB:\nrfm9x.tx_power = 23\n\n# Send a packet.  Note you can only send a packet up to 252 bytes in length.\n# This is a limitation of the radio packet size, so if you need to send larger\n# amounts of data you will need to break it into smaller send calls.  Each send\n# call will wait for the previous one to finish before continuing.\npixel[0] = (255,0,0)  # equivalent\nrfm9x.send(bytes(\"Ping\", \"utf-8\"))\nprint(\"Sent Ping message!\")\npixel[0] = (0,0,255)  # equivalent\n# Wait to receive packets.  Note that this library can't receive data at a fast\n# rate, in fact it can only receive and process one 252 byte packet at a time.\n# This means you should only use this for low bandwidth scenarios, like sending\n# and receiving a single message at a time.\n#print(\"Waiting for packets...\")\n\nrxCounter = 0\n\nwhile True:\n    packet = rfm9x.receive()\n    # Optionally change the receive timeout from its default of 0.5 seconds:\n    # packet = rfm9x.receive(timeout=5.0)\n    # If no packet was received during the timeout then None is returned.\n    if packet is None:\n        # Packet has not been received\n        pixel[0] = (0,0,255)  # equivalent\n        #print(\"Received nothing! Listening again...\")\n    else:\n        # Received a packet!\n        rxCounter = rxCounter + 1\n        pixel[0] = (0,255,0)  # equivalent\n        # Print out the raw bytes of the packet:\n        print(\"Packet Count: {}\".format(rxCounter))\n        # And decode to ASCII text and print it too.  Note that you always\n        # receive raw bytes and need to convert to a text format like ASCII\n        # if you intend to do string processing on your data.  Make sure the\n        # sending side is sending ASCII data before you try to decode!\n        packet_text = str(packet, \"ascii\")\n        print(\"Msg: {0}\".format(packet_text))\n        # Also read the RSSI (signal strength) of the last received message and\n        # print it.\n        rssi = rfm9x.last_rssi\n        print(\"RSSI: {0} dB\".format(rssi))\n        if \"rickme\" in packet_text:\n            RickMe()\n        #time.sleep(3)\n</code></pre> <p>And finally, our payload:</p> payload.txt<pre><code>DELAY 1000\nGUI SPACE\nDELAY 1000\nSTRING terminal.app\nENTER\nDELAY 1000\nSTRING open \"https://youtu.be/dQw4w9WgXcQ\"\nENTER\nDELAY 5000\nSPACE\n</code></pre>"},{"location":"technical/binaries/","title":"LoRa Paw Binaries","text":"<p>NOTICE</p> <p>Software for the LoRa Paw is still under development. However, you can download the latest beta binaries here.</p> USB NuggetBluetooth Nugget <p>Download USB Nugget Binary</p> <p>Download Bluetooth Nugget Binary</p>"},{"location":"technical/pinouts/","title":"Pinouts","text":""},{"location":"technical/pinouts/#pinout-schematics","title":"Pinout Schematics","text":"TopBottom <p> Top Pinout of the LoRa Paw</p> <p> Bottom Pinout of the LoRa Paw</p>"},{"location":"technical/pinouts/#connecting-the-lora-board-to-the-nugget","title":"Connecting the LoRa board to the Nugget","text":"USB NuggetBluetooth Nugget <pre><code>  # Initialize SPI interface\n  spi = busio.SPI(board.IO6, MOSI=board.IO10, MISO=board.IO8)\n\n  # Initialize RFM9x LoRa radio\n  CS = digitalio.DigitalInOut(board.IO13)\n  RESET = digitalio.DigitalInOut(board.IO5)\n  rfm9x = adafruit_rfm9x.RFM9x(spi, CS, RESET, 915.0)\n</code></pre> <pre><code>  # Initialize SPI interface\n  spi = busio.SPI(board.IO6, MOSI=board.IO8, MISO=board.IO7)\n\n  # Initialize RFM9x LoRa radio\n  CS = digitalio.DigitalInOut(board.IO9)\n  RESET = digitalio.DigitalInOut(board.IO4)\n  rfm9x = adafruit_rfm9x.RFM9x(spi, CS, RESET, 915.0)\n</code></pre>"},{"location":"technical/schematics/","title":"Schematics","text":"DefinitionsCircuit Schematic <p> Component Definitions for the LoRa Paw</p> <p> Schematic for the LoRa Paw</p> <p>Download</p>"}]}